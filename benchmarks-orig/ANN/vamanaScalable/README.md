**Usage Guide for ANN**
=======================

**Vamana**
==========

Building
--------

To build an index, use the `./neighbors` program in vamanaScalable/vamana as follows:

```bash
make
./neighbors -a 1.2 -R 25 -L 35 path/to/data/file
``` 

The arguments are as follows:
1. Path to the data file. Currently accepts files in .fvecs or .bvecs format; description of the format and some downloadable datasets can be found [here](http://corpus-texmex.irisa.fr/).
2. **-a**: the pruning parameter alpha. A float greater than 1.0; default value 1.2. Use smaller alpha for sparser graphs and higher alpha for denser graphs. 
3. **-R**: the degree bound of the index. A positive integer; default value 5. Cannot be greater than *L*.
4. **-L**: the size of the search list maintained during building (that is, the frontier size for beam search). Must be greater than *R*. Defaults to 10.

Running this commandline will build an index and print some statistics, such as the average degree.

Querying
--------

In addition to building an index, the same program supports querying the index by taking in a set of queries to perform after the index is built. The commandline is as follows:

```bash
./neighbors -a 1.2 -R 25 -L 35 -k 100 -Q 250 -q path/to/query/file -o path/to/outfile path/to/data/file
```

The first four arguments are described above. The additional arguments are as follows:
1. **-k** the number of nearest neighbors you want to find for each point. Must be at least 1 and at most 1000. Defaults to 1. 
2. **-Q** the size of the search list maintained while searching for the query points. Must be strictly greater than *k*. Defaults to *L*.
3. **-q** path to the query file; file must be in .fvecs or .bvecs format.
4. **-o** path to where the outfile will be written; the outfile consists of the reported nearest neighbors of each query point and can be used to check accuracy.

Reporting Recall
----------------

Now that you've built your index, queried some points, and written their nearest neighbors to an outfile, it's time to check how accurate your results are using the following commandline. This commandline assumes you are still in the `vamana` directory.

```bash
cd ../bench
./neighborsCheck -r [1,5,10] path/to/groundtruth path/to/outfile
```

The arguments are as follows:
1. **-r**: recall parameter. Takes in a string of the form [i,j,k] for integers i, j, k and calculates the recall i@i, j@j, k@k. If you try to use a value *k* greater than the number of nearest neighbors your outfile holds, the compiler will ignore it.
2. Path to the groundtruth file; must be in .ivecs format, described and downloadable [here](http://corpus-texmex.irisa.fr/).
3. Path to the outfile generated by following the steps above.

Dynamic Updates
---------------

Vamana supports dynamic updates in a limited manner in [a branch of pbbsbench]() and [a folder in CPAM](). 

The user must supply the entire dataset in one file. After initially building the graph by passing the `build_index()` function a sequence of at least one integer, the user may insert and delete from the index as desired by modifying the `ANN()` function. 

The `batch_insert()` function requires the following parameters:
1. The data `v` passed to the `ANN` function.
2. A sequence of integers or a single integer. These integers must correspond to indices in `v` and they cannot be already present in the graph.
3. An optional `bool` parameter. Setting to `false` means the list of inserts will be executed in the order provided by the user. Setting to `true` will randomly shuffle the list of inserts before inserting the individual points, which may increase recall. We recommend setting to `false` for debugging and `true` otherwise.

Deletion proceeds in two phases. The function `lazy_delete()` takes two arguments:
1. A sequence of integers or a single integer to delete from the graph. These integers must correspond to indices in `v` and they must have previously been inserted/built into the graph.
2. The data `v` passed to the `ANN` function.

The `lazy_delete()` function does not actually remove points from the graph; rather, it stores them until the user calls the `consolidate_deletes()` function, which performs a batch deletion. 

The following example shows how to use the `ANN()` function to build an index with the entire dataset. It simply passes the `build_index()` function the data and an array of integers from zero to the size of the dataset.

```cpp
template<typename T>
void ANN(parlay::sequence<Tvec_point<T>*> &v, int k, int maxDeg, int beamSize, int beamSizeQ, double alpha, double dummy,
  parlay::sequence<Tvec_point<T>*> &q) {
  parlay::internal::timer t("ANN",report_stats); 
  {
    unsigned d = (v[0]->coordinates).size();
    using findex = knn_index<T>;
    findex I(maxDeg, beamSize, alpha, d);
    parlay::sequence<int> inserts = parlay::tabulate(v.size(), [&] (size_t i){return static_cast<int>(i);});
    I.build_index(v, inserts);
    I.searchNeighbors(q, v, beamSizeQ, k);
    t.next("Found nearest neighbors");
    if(report_stats){
      graph_stats(v);
      query_stats(q);
      t.next("stats");
    }
  };
}
```

The next example presents the following scenario: all the points are inserted into the index, and then the data points are repeatedly deleted and re-inserted in batches of 5% until every point has been re-inserted.

```cpp
template<typename T>
void ANN(parlay::sequence<Tvec_point<T>*> &v, int k, int maxDeg, int beamSize, int beamSizeQ, double alpha, double dummy,
  parlay::sequence<Tvec_point<T>*> &q) {
  parlay::internal::timer t("ANN",report_stats); 
  {
    unsigned d = (v[0]->coordinates).size();
    using findex = knn_index<T>;
    findex I(maxDeg, beamSize, alpha, d);
    parlay::sequence<int> inserts = parlay::tabulate(v.size(), [&] (size_t i){return static_cast<int>(i);});
    I.build_index(v, inserts);
    int parts = 20;
    size_t m = v.size()/parts;
    for(int i=0; i<parts; i++){
      parlay::sequence<int> indices = parlay::tabulate(m, [&] (size_t j){return static_cast<int>(i*m+j);});
      I.lazy_delete(indices, v);
      I.consolidate_deletes(v);
      I.batch_insert(indices, v, true);
    }
    I.searchNeighbors(q, v, beamSizeQ, k);
    t.next("Found nearest neighbors");
    if(report_stats){
      graph_stats(v);
      query_stats(q);
      t.next("stats");
    }
  };
}
```

The next example inserts and deletes with a "sliding window." At first, the last 10% of the points are inserted into the index. Then, points are inserted and deleted in increments of 5% until only the first 10% of the points are present in the index. 


```cpp
template<typename T>
void ANN(parlay::sequence<Tvec_point<T>*> &v, int k, int maxDeg, int beamSize, int beamSizeQ, double alpha, double dummy,
  parlay::sequence<Tvec_point<T>*> &q) {
  parlay::internal::timer t("ANN",report_stats); 
  {
    unsigned d = (v[0]->coordinates).size();
    using findex = knn_index<T>;
    findex I(maxDeg, beamSize, alpha, d);

    int parts = 10; 
    size_t n = v.size();
    size_t m = (size_t) (n/parts);
    size_t r = m/2; 
    parlay::sequence<int> inserts = parlay::tabulate(m, [&] (size_t i){return static_cast<int>(n-i-1);});
    std::cout << "Building with points " << inserts[inserts.size()-1] << " through " << inserts[0] << std::endl; 
    I.build_index(v, inserts);
    for(int i=parts*2-1; i>1; i--){
      parlay::sequence<int> delete_list = parlay::tabulate(r, [&] (size_t j){return static_cast<int>(((i)*r)+r-j-1);});
      std::cout << "Deleting points " << delete_list[delete_list.size()-1] << " through " << delete_list[0] << std::endl; 
      I.lazy_delete(delete_list, v);
      I.consolidate_deletes(v);
      parlay::sequence<int> insert_list = parlay::tabulate(r, [&] (size_t j){return static_cast<int>(((i)*r)-r-j-1);});
      std::cout << "Inserting points " << insert_list[insert_list.size()-1] << " through " << insert_list[0] << std::endl; 
      I.batch_insert(insert_list, v, true);
    }
    t.next("Built index");

    I.searchNeighbors(q, v, beamSizeQ, k);
    t.next("Found nearest neighbors");
    if(report_stats){
      graph_stats(v);
      query_stats(q);
      t.next("stats");
    }
  };
}
```
